#include <ros/ros.h>
#include "assignment_3/UpdateGrid.h"
#include "assignment_3/Sensor.h"
#include "communal_defines.cpp"
#include <std_msgs/String.h>
#include <std_msgs/Int32.h>
#include <std_msgs/Int32MultiArray.h>
#include <std_msgs/MultiArrayDimension.h>
#include <vector>
#include <random>
#include <fstream>
#include <queue>
#include <string>
#include <utility>

#define GAZEBO_SIMULATION_RATE 3 // how many moves per second will that will be processed/simulated

// boolean expects sub_x and sub_y to determine if sub is at home position
#define SubIsHome(sub_x, sub_y) (sub_x == SUB_START_X && sub_y == SUB_START_Y)

// path names, used to keep track of which path is currently being executed
#define SURVEY_AREA 0
#define COLLECT_SURVIVORS 1
#define GO_HOME 2

// global variable for whenever the home directory is needed
std::string homeDir = getenv("HOME");
// path to the PAT executable
#define PAT_EXE_DIR homeDir + "/Desktop/MONO-PAT-v3.6.0/PAT3.Console.exe"
// path to the explore path csp file for PAT
#define PAT_PATH_CSP_EXPLORE_DIR homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/explore.csp"
// path to the return home path csp file for PAT
#define PAT_PATH_CSP_HOME_DIR homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/return_home.csp"
// path to the collect survivors path csp file for PAT
#define PAT_PATH_CSP_COLLECT_SURVIVORS_DIR homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/collect_survivors.csp"
// path to the output file generated by PAT
#define PAT_OUTPUT_DIR homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/pat_output.txt"
// path to world file generated by robot before calling PAT
#define PAT_WORLD_DIR homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/world.csp"
// timeout duration for BFS searches
#define MAX_BFS_TIME 10
// file path to state txt file
#define STATE_FILE homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/state.txt"
// file path to task txt file
#define TASK_FILE homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/task.txt"
// path to validation CSP file for PAT
#define PAT_VALIDATION_CSP_DIR homeDir + "/catkin_ws/src/3806ict_assignment_3/pat/validation.csp"

// cmd to execute PAT using the explore path
std::string PAT_CMD_EXPLORE = "mono " + PAT_EXE_DIR + " " + PAT_PATH_CSP_EXPLORE_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the go home path with the BFS engine
std::string PAT_CMD_GO_HOME_BFS = "timeout " + std::to_string(MAX_BFS_TIME) + "s mono " + PAT_EXE_DIR + " -engine 1 " + PAT_PATH_CSP_HOME_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the go home path with the DFS engine
std::string PAT_CMD_GO_HOME_DFS = "mono " + PAT_EXE_DIR + " -engine 1 " + PAT_PATH_CSP_HOME_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the collect survivors path with the BFS engine
std::string PAT_CMD_COLLECT_SURVIVORS_BFS = "timeout " + std::to_string(MAX_BFS_TIME) + "s mono " + PAT_EXE_DIR + " -engine 1 " + PAT_PATH_CSP_COLLECT_SURVIVORS_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the collect survivors path with the DFS engine
std::string PAT_CMD_COLLECT_SURVIVORS_DFS = "mono " + PAT_EXE_DIR + " " + PAT_PATH_CSP_COLLECT_SURVIVORS_DIR + " " + PAT_OUTPUT_DIR;

// -- function declarations --
void detect_hostiles(assignment_3::Sensor &hostile_srv, int (&curr_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y);
int detect_survivors(assignment_3::Sensor &survivor_srv, int (&curr_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y);
std::pair<int, int> update_position(std::string &move, int &x, int &y);
void update_directions(std::queue<std::string> &q);
void generate_world(int (&world)[BOARD_H][BOARD_W]);
void generate_known_world(int (&world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, int &onBoard);
std::vector<int> translate_world(int (&world)[BOARD_H][BOARD_W]);
void regenerate_moves(int (&current_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, int &onBoard, std::queue<std::string> &q, int currentPath);
void execute_move(int (&current_world)[BOARD_H][BOARD_W], int (&true_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, std::pair<int, int> &new_coords);
void write_state(int (&curr_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, int &survivors_saved, int &onBoard);
std_msgs::Int32MultiArray createGrid(int (&true_world)[BOARD_H][BOARD_W]);
int count_known_survivors(int (&world)[BOARD_H][BOARD_W]);
int read_task();
void generate_csp(int saved, int onboard, int known_survivors, int unknown_survivors, int task);
bool is_validation_valid();

int main(int argc, char *argv[])
{
    // initialise ros, services, and grid
    ros::init(argc, argv, "testing");
    ros::NodeHandle n;
    ros::ServiceClient gridClient = n.serviceClient<assignment_3::UpdateGrid>("/update_grid");
    ros::ServiceClient hostileSensorClient = n.serviceClient<assignment_3::Sensor>("/hostile_sensor");
    ros::ServiceClient survivorSensorClient = n.serviceClient<assignment_3::Sensor>("/survivor_sensor");
    assignment_3::UpdateGrid grid_srv;
    assignment_3::Sensor hostile_srv;
    assignment_3::Sensor survivor_srv;
    std_msgs::Int32MultiArray true_grid;

    int survivors_saved = 0;
    int survivors_seen = 0;
    int OnBoard = 0;
    int true_world[BOARD_H][BOARD_W];
    int current_world[BOARD_H][BOARD_W];
    // initialise current_world to EMPTY
    for (int i = 0; i < BOARD_H; i++)
        for (int j = 0; j < BOARD_W; j++)
            current_world[i][j] = EMPTY;
    // current world position is visited
    current_world[SUB_START_X][SUB_START_Y] = VISITED;
    int sub_x = SUB_START_X;
    int sub_y = SUB_START_Y;
    int currentPath = SURVEY_AREA;

    // randomly generate a new world
    generate_world(true_world);

    // transfer the data from int array to std_msgs::Int32MultiArray to be sent via service
    true_grid = createGrid(true_world);
    grid_srv.request.grid = true_grid;

    // send the true world to be modelled by gazebo
    if (!gridClient.call(grid_srv))
    {
        ROS_ERROR("Failed to call update_grid service");
        return EXIT_FAILURE;
    }

    // initalise a queue to hold the moveset
    std::queue<std::string> q;
    // initise the sensor ranges
    hostile_srv.request.sensorRange = HOSTILE_DETECTION_RANGE;
    survivor_srv.request.sensorRange = SURVIVOR_DETECTION_RANGE;
    // extract information from sensors at starting position
    if (!hostileSensorClient.call(hostile_srv) || !survivorSensorClient.call(survivor_srv))
    {
        ROS_ERROR("Failed to call sensor services");
        return EXIT_FAILURE;
    }

    // update our current world with any detected hostiles or survivors
    detect_hostiles(hostile_srv, current_world, sub_x, sub_y);
    int newSurvivorsDetected = detect_survivors(survivor_srv, current_world, sub_x, sub_y);

    if (newSurvivorsDetected)
    {
        // detected a survivor, change our planning to pick them up ASAP
        ROS_INFO("New survivor(s) detected!");
        survivors_seen += newSurvivorsDetected;
        currentPath = COLLECT_SURVIVORS; // attempt to pick up the any survivors around us if space permits
    }

    // regenerate the moveset with the current path
    regenerate_moves(current_world, sub_x, sub_y, OnBoard, q, currentPath);

    // initialise current move
    std::string next_move;

    // initialise the rate which controls the looping speed
    ros::Rate rate(GAZEBO_SIMULATION_RATE);

    // continue looping while ros is ready to process commands
    while (ros::ok())
    {
        ROS_INFO("-- Start of move cycle --");

        if (SubIsHome(sub_x, sub_y) && OnBoard)
        { // sub is at home position and has survivors on board
            // drop off any survivors
            survivors_saved += OnBoard;
            std::cout << "Saved " << OnBoard << " survivors. Total survivors now saved: " << survivors_saved << std::endl;
            // now have no one on board
            OnBoard = 0;
        }

        // there are no moves left to extract
        if (q.empty())
        {
            // robot has collected all survivors (either on board or already safe)
            if ((survivors_saved + OnBoard) == SURVIVOR_COUNT)
            {
                // robot is currently home, which means the mission is complete
                if (SubIsHome(sub_x, sub_y))
                {
                    ROS_INFO("Mission successful!\nFinal internal representation of environment:");
                    for (int i = 0; i < BOARD_H; i++)
                    {
                        for (int j = 0; j < BOARD_W; j++)
                        {
                            if (current_world[i][j] != VISITED)
                                std::cout << " ";
                            std::cout << current_world[i][j] << " ";
                        }
                        std::cout << std::endl;
                    }
                    return EXIT_SUCCESS;
                }
                else // saved all survivors, but not home yet
                    currentPath = GO_HOME;
            }
            else
            {
                // Compute current state for validation
                int known_survivors = count_known_survivors(current_world);
                int unknown_survivors = SURVIVOR_COUNT - survivors_saved - OnBoard - known_survivors;
                int task = read_task();
                if (task == -1 || !is_validation_valid())
                {
                    currentPath = (OnBoard > 0) ? GO_HOME : SURVEY_AREA; // State-based fallback
                }
                else
                {
                    currentPath = task;
                }
            }
            // regenerate moveset with current path
            regenerate_moves(current_world, sub_x, sub_y, OnBoard, q, currentPath);
        }
        // retrieve next move and remove it from queue
        next_move = std::string(q.front());
        q.pop();
        ROS_INFO("Next move is: %s", next_move.c_str());

        // generate new coordinates from move
        std::pair<int, int> new_coords = update_position(next_move, sub_x, sub_y);
        int new_x = new_coords.first;
        int new_y = new_coords.second;

        // checking all conditions which would prevent us from being able to move
        // check if we're about to collide with a hostile/obstacle
        if (current_world[new_x][new_y] == HOSTILE)
        {
            ROS_INFO("About to move into hostile, recalculating PAT directions");
            // need directions which follow our current path, but avoids the hostile
            regenerate_moves(current_world, sub_x, sub_y, OnBoard, q, currentPath);
            rate.sleep();
            continue;
        }

        // must not be moving into a hostile, so continue!
        // if we're going to move into a survivor, it was
        // planned/intentional, so we are safe to pick them up
        if (current_world[new_x][new_y] == SURVIVOR)
        {
            ROS_INFO("About to pick up a survivor :) Hooray!");
            OnBoard++;
            std::cout << "Now have " << OnBoard << " survivors onboard" << std::endl;
        }

        // updating true and internal representations
        execute_move(current_world, true_world, sub_x, sub_y, new_coords);

        // pushing the changes to gazebo
        // translate world to vector for multiarray
        true_grid.data = translate_world(true_world);
        grid_srv.request.grid = true_grid;

        // send the true world to be modelled by gazebo
        if (!gridClient.call(grid_srv))
        {
            ROS_ERROR("Failed to call update_grid service");
            return EXIT_FAILURE;
        }

        // now we are at the new position in gazebo, we can update our own positions
        sub_x = new_x;
        sub_y = new_y;

        // call the sensors and extract information
        if (!hostileSensorClient.call(hostile_srv) || !survivorSensorClient.call(survivor_srv))
        {
            ROS_ERROR("Failed to call sensor services");
            return EXIT_FAILURE;
        }

        // update our current world with any detected hostiles or survivors
        detect_hostiles(hostile_srv, current_world, sub_x, sub_y);
        newSurvivorsDetected = detect_survivors(survivor_srv, current_world, sub_x, sub_y);

        if (newSurvivorsDetected)
        {
            // detected a survivor, change our planning to pick them up ASAP
            ROS_INFO("New survivor(s) detected!");
            survivors_seen += newSurvivorsDetected;
            currentPath = COLLECT_SURVIVORS;
            // regenerate the moveset to collect any detected survivors
            regenerate_moves(current_world, sub_x, sub_y, OnBoard, q, currentPath);
        }

        // write state to a txt file to be read by other nodes
        write_state(current_world, sub_x, sub_y, survivors_saved, OnBoard);

        ROS_INFO("-- End of move cycle --\n");
        rate.sleep(); // sleep for remaining time in cycle
        ros::spinOnce();
    }
}

void detect_hostiles(assignment_3::Sensor &hostile_srv, int (&curr_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y)
{
    // hostile detection. sensor gives general direction indicator (objectEast)
    // and an array of positions which correlate to distances. e.g. eastRadar = [0, 1]
    // inidicates a hostile is 2 positions away.
    // east is col + 1
    if (hostile_srv.response.objectEast)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.eastRadar[i])
            {
                curr_world[sub_x][sub_y + 1 + i] = HOSTILE;
                ROS_INFO("Robot has detected a hostile east!");
            }
    // west is col - 1
    if (hostile_srv.response.objectWest)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.westRadar[i])
            {
                curr_world[sub_x][sub_y - 1 - i] = HOSTILE;
                ROS_INFO("Robot has detected a hostile west!");
            }
    // north is row - 1
    if (hostile_srv.response.objectNorth)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.northRadar[i])
            {
                curr_world[sub_x - 1 - i][sub_y] = HOSTILE;
                ROS_INFO("Robot has detected a hostile north!");
            }
    // south is row + 1
    if (hostile_srv.response.objectSouth)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.southRadar[i])
            {
                curr_world[sub_x + 1 + i][sub_y] = HOSTILE;
                ROS_INFO("Robot has detected a hostile south!");
            }
}

int detect_survivors(assignment_3::Sensor &survivor_srv, int (&curr_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y)
{
    // survivor detection. sensor gives general direction indicator (objectEast)
    // and an array of positions which correlate to distances. e.g. eastRadar = [1]
    // inidicates a survivor is 1 positions away.
    // east is col + 1
    int newSurvivorsDetected = 0;
    // east is col + 1
    if (survivor_srv.response.objectEast)
        for (int i = 0; i < survivor_srv.request.sensorRange; i++)
            if (survivor_srv.response.eastRadar[i])
                if (curr_world[sub_x][sub_y + 1 + i] != SURVIVOR)
                {
                    newSurvivorsDetected++;
                    curr_world[sub_x][sub_y + 1 + i] = SURVIVOR;
                    ROS_INFO("Robot has detected a survivor east!");
                }
    // west is col - 1
    if (survivor_srv.response.objectWest)
        for (int i = 0; i < survivor_srv.request.sensorRange; i++)
            if (survivor_srv.response.westRadar[i])
                if (curr_world[sub_x][sub_y - 1 - i] != SURVIVOR)
                {
                    newSurvivorsDetected++;
                    curr_world[sub_x][sub_y - 1 - i] = SURVIVOR;
                    ROS_INFO("Robot has detected a survivor west!");
                }
    // north is row - 1
    if (survivor_srv.response.objectNorth)
        for (int i = 0; i < survivor_srv.request.sensorRange; i++)
            if (survivor_srv.response.northRadar[i])
                if (curr_world[sub_x - 1 - i][sub_y] != SURVIVOR)
                {
                    newSurvivorsDetected++;
                    curr_world[sub_x - 1 - i][sub_y] = SURVIVOR;
                    ROS_INFO("Robot has detected a survivor north!");
                }
    // south is row + 1
    if (survivor_srv.response.objectSouth)
        for (int i = 0; i < survivor_srv.request.sensorRange; i++)
            if (survivor_srv.response.southRadar[i])
                if (curr_world[sub_x + 1 + i][sub_y] != SURVIVOR)
                {
                    newSurvivorsDetected++;
                    curr_world[sub_x + 1 + i][sub_y] = SURVIVOR;
                    ROS_INFO("Robot has detected a survivor south!");
                }
    return newSurvivorsDetected;
}

std::pair<int, int> update_position(std::string &move, int &x, int &y)
{
    // moving right is col + 1
    if (move == "moveRight")
        return {x, y + 1};
    // moving left is col - 1
    else if (move == "moveLeft")
        return {x, y - 1};
    // moving up is row - 1
    else if (move == "moveUp")
        return {x - 1, y};
    // moving down is row + 1
    else if (move == "moveDown")
        return {x + 1, y};
    std::cerr << "update_position found invalid move: " << move << std::endl;
    return {x, y};
}

void update_directions(std::queue<std::string> &q)
{
    // open the output file generated by PAT.
    std::ifstream pat_output(PAT_OUTPUT_DIR);
    if (!pat_output.is_open())
    {
        std::cerr << "Failed to open PAT output file!" << std::endl;
        exit(1);
    }
    // remove all current direcitons
    while (!q.empty())
        q.pop();
    // line used to read lines from output
    std::string line;
    // move used to read moves
    std::string move;
    while (getline(pat_output, line))
    {                              // continue reading lines from output file
        if (line[0] == '<') // line with moveset always starts with < (<init>)
        {
            // create a string stream from the line so that we may read into move
            std::istringstream ss(line);
            ss >> move; // skip <init
            // each move will be preceded by " -> "
            while (ss >> move) // while move preceded by " -> "
            {
                ss >> move;
                // now move var has current move
                q.push(move); // push current move onto queue
            }
            // removing '>' from last move
            q.back().pop_back();
            break; // no need to continue looping after moves have been read
        }
    }
    // close output file
    pat_output.close();
    return;
}

void generate_world(int (&world)[BOARD_H][BOARD_W])
{
    // init world with EMPTY
    for (int i = 0; i < BOARD_H; ++i)
        for (int j = 0; j < BOARD_W; ++j)
            world[i][j] = EMPTY;

    // place sub in home position denoted by SUB_START_X and SUB_START_Y (origin)
    world[SUB_START_X][SUB_START_Y] = SUB;

    // random number generators for random row/column
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<int> rowDist(0, BOARD_H - 1);
    std::uniform_int_distribution<int> colDist(0, BOARD_W - 1);

    // place survivors randomly
    int placed = 0;
    while (placed < SURVIVOR_COUNT)
    {
        int rand_row = rowDist(gen);
        int rand_col = colDist(gen);
        if (world[rand_row][rand_col] == EMPTY)
        {
            world[rand_row][rand_col] = SURVIVOR;
            placed++;
        }
    }

    // place hostiles randomly
    placed = 0;
    while (placed < HOSTILE_COUNT)
    {
        int rand_row = rowDist(gen);
        int rand_col = colDist(gen);
        if (world[rand_row][rand_col] == EMPTY)
        {
            world[rand_row][rand_col] = HOSTILE;
            placed++;
        }
    }
}

void generate_known_world(int (&world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, int &onBoard)
{
    // open world.csp file to write to
    std::ofstream file(PAT_WORLD_DIR);
    if (!file.is_open())
    {
        std::cerr << "Failed to save the current world to world.csp" << std::endl;
        exit(1);
    }
    ROS_INFO("Writing robot's current interpretation to world file.");

    // write defines
    file << "#define Visited " << VISITED << ";\n";
    file << "#define Unvisited " << EMPTY << ";\n";
    file << "#define Sub " << SUB << ";\n";
    file << "#define Hostile " << HOSTILE << ";\n";
    file << "#define Survivor " << SURVIVOR << ";\n\n";
    file << "#define SUB_HOME_X " << SUB_START_X << ";\n";
    file << "#define SUB_HOME_Y " << SUB_START_Y << ";\n";
    file << "#define Rows " << BOARD_H << ";\n";
    file << "#define Cols " << BOARD_W << ";\n";
    file << "#define maxCapacity " << SUB_CAP << ";\n";

    // write new array representation of world
    file << "\nvar world[Rows][Cols]:{Visited..Survivor} = [\n";
    for (int i = 0; i < BOARD_H; i++)
    {
        for (int j = 0; j < BOARD_W; j++)
        {
            if (i == BOARD_H - 1 && j == BOARD_W - 1)
                file << world[i][j];
            else
                file << world[i][j] << ", ";
        }
        file << "\n";
    }
    file << "];\n\n";

    file << "// Position of sub\n";
    file << "var xpos:{0..Rows-1} = " << sub_x << ";\n";
    file << "var ypos:{0..Cols-1} = " << sub_y << ";\n";
    file << "var onBoard:{0..maxCapacity} = " << onBoard << ";\n";

    file.close();
}

std::vector<int> translate_world(int (&world)[BOARD_H][BOARD_W])
{
    std::vector<int> vec(BOARD_W * BOARD_H, EMPTY);
    for (int i = 0; i < BOARD_H; i++)
        for (int j = 0; j < BOARD_W; j++)
            vec[i * BOARD_W + j] = world[i][j];
    return vec;
}

void regenerate_moves(int (&current_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, int &onBoard, std::queue<std::string> &q, int currentPath)
{
    // generate world.csp so path.csp has access to current environment
    generate_known_world(current_world, sub_x, sub_y, onBoard);

    // get output from pat (generate pat_output.txt)
    if (currentPath == SURVEY_AREA)
    {
        ROS_INFO("Calculating a path to survey remaining area");
        std::system(PAT_CMD_EXPLORE.c_str());
    }
    else if (currentPath == COLLECT_SURVIVORS)
    {
        ROS_INFO("Calculating a path to collect remaining survivors");
        // collect status code returned from the system call
        int status = std::system(PAT_CMD_COLLECT_SURVIVORS_BFS.c_str());
        // fatal error if status call is not positive integer
        if (status < 0)
        {
            std::cout << "There has been a fatal error!: " << strerror(errno) << '\n';
            exit(1);
        }
        else
        {
            if (WIFEXITED(status))
            {
                if (WEXITSTATUS(status) == 124)
                { // exit code is 124 if timeout kills process due to exceeded time limit
                    // in this case, we want to run the DFS version of the same algorithm
                    // as we expect it to run faster
                    ROS_INFO("BFS Path calculation for survivor collection took too long, now calculating DFS path.");
                    std::system(PAT_CMD_COLLECT_SURVIVORS_DFS.c_str());
                }
            }
            // system call must have been killed, or fatal error
            else
            {
                std::cout << "PAT call was killed :(\n";
                exit(1);
            }
        }
    }
    else if (currentPath == GO_HOME)
    {
        ROS_INFO("Calculating a path to go home");
        // collect status code returned from the system call
        int status = std::system(PAT_CMD_GO_HOME_BFS.c_str());
        // fatal error if status call is not positive integer
        if (status < 0)
        {
            std::cout << "There has been a fatal error!: " << strerror(errno) << '\n';
            exit(1);
        }
        else
        {
            if (WIFEXITED(status))
            {
                if (WEXITSTATUS(status) == 124)
                { // exit code is 124 if timeout kills process due to exceeded time limit
                    // in this case, we want to run the DFS version of the same algorithm
                    // as we expect it to run faster
                    ROS_INFO("BFS Path calculation for going home took too long, now calculating DFS path.");
                    std::system(PAT_CMD_GO_HOME_DFS.c_str());
                }
            }
            // system call must have been killed, or fatal error
            else
            {
                std::cout << "PAT call was killed :(\n";
                exit(1);
            }
        }
    }
    else
    {
        ROS_WARN("Received unknown path command! Aborting mission!");
        exit(1);
    }

    // extract directions given by PAT in output file
    update_directions(q);
}

void execute_move(int (&current_world)[BOARD_H][BOARD_W], int (&true_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, std::pair<int, int> &new_coords)
{
    // change internal representation (new position now visited)
    int new_x = new_coords.first;
    int new_y = new_coords.second;
    current_world[new_x][new_y] = VISITED;

    // change true representation (old position now visited, new position now sub)
    true_world[sub_x][sub_y] = VISITED;
    true_world[new_x][new_y] = SUB;
}

std_msgs::Int32MultiArray createGrid(int (&true_world)[BOARD_H][BOARD_W])
{
    // used to convert from 1D array back to 2D array
    std_msgs::Int32MultiArray true_grid;
    true_grid.layout.dim.push_back(std_msgs::MultiArrayDimension());
    true_grid.layout.dim.push_back(std_msgs::MultiArrayDimension());
    true_grid.layout.dim[0].label = "height";
    true_grid.layout.dim[1].label = "width";
    true_grid.layout.dim[0].size = BOARD_H;
    true_grid.layout.dim[1].size = BOARD_W;
    true_grid.layout.dim[0].stride = BOARD_H * BOARD_W;
    true_grid.layout.dim[1].stride = BOARD_W;
    true_grid.layout.data_offset = 0;
    true_grid.data = translate_world(true_world);
    return true_grid;
}

void write_state(int (&curr_world)[BOARD_H][BOARD_W], int &sub_x, int &sub_y, int &survivors_saved, int &onBoard)
{
    std::ofstream file(STATE_FILE);
    if (!file.is_open())
    {
        ROS_ERROR("Failed to write state to file.");
        return;
    }
    file << "grid: [";
    for (int i=0; i < BOARD_H; i++)
        for (int j=0; j < BOARD_W; j++)
            file << curr_world[i][j] << (i == BOARD_H - 1 && j == BOARD_W - 1? "" : ", ");
    file << "]; x: " << sub_x << "; y: " << sub_y << "; saved: " << survivors_saved << "; onboard: " << onBoard;
    file.close();
}

int count_known_survivors(int (&world)[BOARD_H][BOARD_W])
{
    int count = 0;
    for (int i = 0; i < BOARD_H; i++)
    {
        for (int j = 0; j < BOARD_W; j++)
        {
            if (world[i][j] == SURVIVOR)
            {
                count++;
            }
        }
    }
    return count;
}

int read_task()
{
    std::ifstream file(TASK_FILE);
    if (!file.is_open())
    {
        ROS_ERROR("Failed to open task file");
        return -1;
    }
    std::string task_str;
    std::getline(file, task_str);
    file.close();
    if (task_str == "0") return GO_HOME;           // LLM 0 -> PAT 2 (GO_HOME)
    if (task_str == "1") return COLLECT_SURVIVORS; // LLM 1 -> PAT 1 (COLLECT_SURVIVORS)
    if (task_str == "2") return SURVEY_AREA;       // LLM 2 -> PAT 0 (SURVEY_AREA)
    ROS_ERROR("Invalid task value in file");
    return -1;
}

void generate_csp(int saved, int onboard, int known_survivors, int unknown_survivors, int task)
{
    std::ofstream file(PAT_VALIDATION_CSP_DIR);
    if (!file.is_open())
    {
        ROS_ERROR("Failed to open validation CSP file for writing");
        return;
    }

    // Write CSP# model with current state and task
    file << "#define SURVIVOR_COUNT 5;\n";
    file << "#define SUB_CAP 2;\n";
    file << "#define AllSurvivorsSaved (saved == SURVIVOR_COUNT);\n\n";

    // Set current state
    file << "var saved:{0..SURVIVOR_COUNT} = " << saved << ";\n";
    file << "var onboard:{0..SUB_CAP} = " << onboard << ";\n";
    file << "var known_survivors:{0..SURVIVOR_COUNT} = " << known_survivors << ";\n";
    file << "var unknown_survivors:{0..SURVIVOR_COUNT} = " << unknown_survivors << ";\n\n";

    // CSP# processes
    file << "Explore() = [unknown_survivors > 0] (\n";
    file << "    find {known_survivors = known_survivors + 1; unknown_survivors = unknown_survivors - 1;} -> Robot()\n";
    file << "    [] nofind -> Robot()\n";
    file << ") [] [unknown_survivors == 0] skip -> Robot();\n\n";

    file << "Rescue() = [known_survivors > 0 && onboard < SUB_CAP] pickup {known_survivors = known_survivors - 1; onboard = onboard + 1;} -> Robot();\n\n";

    file << "ReturnHome() = [onboard > 0] dropoff {saved = saved + onboard; onboard = 0;} -> Robot();\n\n";

    // Define Robot() to recursively execute tasks until all survivors are saved
    file << "Robot() = (\n";
    file << "    [saved < SURVIVOR_COUNT] (\n";
    file << "        [onboard > 0] ReturnHome()\n";
    file << "        [] [known_survivors > 0 && onboard < SUB_CAP] Rescue()\n";
    file << "        [] [unknown_survivors > 0] Explore()\n";
    file << "    )\n";
    file << ") [] [saved == SURVIVOR_COUNT] skip;\n\n";

    // System starts with the chosen task and then continues with Robot()
    file << "System() = (\n";
    if (task == GO_HOME)
    {
        file << "    ReturnHome() -> Robot()\n";
    }
    else if (task == COLLECT_SURVIVORS)
    {
        file << "    Rescue() -> Robot()\n";
    }
    else if (task == SURVEY_AREA)
    {
        file << "    Explore() -> Robot()\n";
    }
    else
    {
        file << "    Robot()\n"; // Default to full Robot process if task invalid
    }
    file << ");\n\n";

    // Assertion to validate the task
    file << "#assert System() reaches AllSurvivorsSaved;\n";

    file.close();
}

bool is_validation_valid()
{
    std::ifstream file(PAT_OUTPUT_DIR);
    if (!file.is_open())
    {
        ROS_ERROR("Failed to open PAT output file");
        return false;
    }
    std::string line;
    while (std::getline(file, line))
    {
        if (line.find("The Assertion is VALID") != std::string::npos)
        {
            file.close();
            return true;
        }
    }
    file.close();
    return false;
}